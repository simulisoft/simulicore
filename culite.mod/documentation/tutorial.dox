/**
 * @page culite_tutorial Quick Start Guide
 * @brief Basic concepts and usage examples for the cuLite library.
 * @details This guide provides a collection of examples designed to help users familiarize 
 * themselves with the cuLite API and understand its core capabilities. 
 * Each example is structured to demonstrate best practices for high-performance 
 * GPU computing while maintaining code readability.
 * 
 * To get started, select a category below to browse the relevant implementation examples. 
 * Whether you are migrating from standard CUDA or starting a fresh project, these 
 * modules offer a step-by-step progression through the library's features.
 *
 *
 *  - @subpage culite_tutorial_datatypes
 *  - @subpage culite_tutorial_vectors
 *
 *
 *
 *
 *
 *
 * @page culite_tutorial_datatypes Datatypes
 * 
 * cuLite utilizes a set of internal datatypes designed for seamless integration with NVIDIA CUDA environments. 
 * These types ensure consistency across both host and device code while maintaining compatibility with standard 
 * CUDA complex types.
 *
 * ### Supported Datatypes
 *
 * The following aliases are provided within the `culite` namespace:
 *
 * | cuLite Type | Underlying C++/CUDA Type | Description |
 * | :--- | :--- | :--- |
 * |      culite::int_t | `int32_t` or `int64_t` | Signed integer (bit-width depends on build mode) |
 * |      culite::uint_t | `uint32_t` or `uint64_t` | Unsigned integer (bit-width depends on build mode) |
 * | @ref culite::real_t | `double` | Double precision real |
 * | @ref culite::real4_t | `float` | Single precision real |
 * | @ref culite::complex_t | `cuDoubleComplex` | Double precision complex (binary compatible with `std::complex<double>`) |
 * | @ref culite::complex8_t | `cuFloatComplex` | Single precision complex (binary compatible with `std::complex<float>`) |
 *
 * ### Integer Precision Configuration
 *
 * By default, cuLite uses 32-bit integers for its index types. You can toggle between 32-bit and 64-bit precision 
 * using the following configuration:
 *
 * - **32-bit Integers (Default):** Link your application with the standard library (`libculite.so` / `culite.lib`).
 * - **64-bit Integers:** Add the `-DCULITE_I64` flag to your compiler flags and link with the 64-bit enabled 
 *   library (`libculite_i64.so` / `culite_i64.lib`).
 *
 * Example:
 * @code{.cpp}
 * culite::int_t i;      // Width determined by -DCULITE_I64 flag
 * culite::real_t d;     // Always double precision
 * culite::complex_t z;  // cuDoubleComplex structure
 * @endcode
 *
 *
 *
 *
 *
 *
 * @page culite_tutorial_vectors Vectors
 *  - @subpage culite_tutorial_vectors_dense
 *
 * @page culite_tutorial_vectors_dense Dense Vectors
 *
 * cuLite provides specialized classes for managing dense vectors on NVIDIA GPU devices. 
 * These classes are optimized for CUDA-accelerated linear algebra operations and support 
 * both real and complex numerical types.
 *
 * ### Available Dense Vector Types
 *
 * The following classes are defined within the `culite::dns` namespace:
 *
 * | cuLite Class | Numeric Type | Precision |
 * | :--- | :--- | :--- |
 * | @ref culite::dns::RdVector | `double` | Double precision real |
 * | @ref culite::dns::RfVector | `float` | Single precision real |
 * | @ref culite::dns::CdVector | `cuDoubleComplex` | Double precision complex |
 * | @ref culite::dns::CfVector | `cuFloatComplex` | Single precision complex |
 *
 * @section culite_tutorial_vectors_dense_create Creating vectors
 *
 * You can instantiate dense vectors using several initialization strategies, ranging from 
 * empty containers to pre-allocated device memory.
 *
 * @subsection culite_tutorial_vectors_dense_create_default Default and Sized Creation
 *
 * Dense vectors can be declared as empty objects or with a predefined size to trigger immediate 
 * allocation on the GPU.
 *
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex01a_dense_vector_create.cpp </td>
 *     <td> @include i32/out/ex01a_dense_vector_create.out </td>
 *   </tr>
 * </table>
 *
 */

