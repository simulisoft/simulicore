/**
 * @page cla3p_tutorial Quick Start Guide
 * @brief Essential concepts and implementation examples for the CLA3P library.
 * @details This section provides a curated collection of examples designed to demonstrate 
 * the fundamental principles of CLA3P. These modules serve as a practical 
 * introduction, helping you quickly master the CLA3P API and leverage its 
 * high-performance linear algebra capabilities in your own projects.
 * 
 * To begin, select a category from the list below to explore the corresponding 
 * code samples. Whether you are performing basic matrix operations or complex 
 * numerical decompositions, these guides offer a structured path to efficient 
 * library integration.
 *
 *  - @subpage cla3p_tutorial_datatypes
 *  - @subpage cla3p_tutorial_vectors
 *  - @subpage cla3p_tutorial_property
 *  - @subpage cla3p_tutorial_matrices
 *  - @subpage cla3p_tutorial_guard
 *  - @subpage cla3p_tutorial_assign
 *  - @subpage cla3p_tutorial_block_ops
 *  - @subpage cla3p_tutorial_perm
 *  - @subpage cla3p_tutorial_linsol
 *  - @subpage cla3p_tutorial_qr
 *  - @subpage cla3p_tutorial_svd
 * 
 *
 *
 *
 *
 *
 *
 * @page cla3p_tutorial_datatypes Datatypes
 *
 * CLA3P utilizes a set of predefined types to ensure consistency across different architectures and precision requirements.
 *
 * ### Supported Types
 *
 * The following table illustrates the primary datatypes available in the CLA3P namespace:
 *
 * | CLA3P Type | Equivalent C++ Type | Description |
 * | :--- | :--- | :--- |
 * |      cla3p::int_t | `int32_t` or `int64_t` | Signed integer (width depends on build configuration) |
 * |      cla3p::uint_t | `uint32_t` or `uint64_t` | Unsigned integer (width depends on build configuration) |
 * | @ref cla3p::real_t | `double` | Double precision real |
 * | @ref cla3p::real4_t | `float` | Single precision real |
 * | @ref cla3p::complex_t | `std::complex<double>` | Double precision complex |
 * | @ref cla3p::complex8_t | `std::complex<float>` | Single precision complex |
 *
 * ### Integer Precision Configuration
 *
 * The bit-width of cla3p::int_t and cla3p::uint_t is configurable at compile-time:
 *
 * - **32-bit Integers (Default):** Link against the standard library (`libcla3p.so` / `cla3p.lib`).
 * - **64-bit Integers:** Define the `-DCLA3P_I64` preprocessor macro during compilation and link against the 64-bit enabled library (`libcla3p_i64.so` / `cla3p_i64.lib`).
 *
 * Example:
 * @code{.cpp}
 * cla3p::int_t  i = -5;
 * cla3p::real_t d = 1.234;
 * cla3p::complex_t z(1.0, -1.0);
 * @endcode
 *
 *
 *
 *
 *
 *
 *
 * @page cla3p_tutorial_vectors Vectors
 *  - @subpage cla3p_tutorial_vectors_dense
 *
 * @page cla3p_tutorial_vectors_dense Dense Vectors
 *
 * CLA3P provides a set of specialized classes for handling dense vectors. 
 * These classes are optimized for linear algebra operations and support 
 * both real and complex numerical types with single and double precision.
 *
 * ### Available Dense Vector Types
 *
 * The following classes are defined within the `cla3p::dns` namespace:
 *
 * | CLA3P Class | Numeric Type | Precision |
 * | :--- | :--- | :--- |
 * | @ref cla3p::dns::RdVector | `double` | Double precision real |
 * | @ref cla3p::dns::RfVector | `float` | Single precision real |
 * | @ref cla3p::dns::CdVector | `std::complex<double>` | Double precision complex |
 * | @ref cla3p::dns::CfVector | `std::complex<float>` | Single precision complex |
 *
 * Example:
 * @code{.cpp}
 * // Instantiate a double precision real vector
 * cla3p::dns::RdVector Xd(10); 
 * 
 * // Instantiate a single precision complex vector
 * cla3p::dns::CfVector Xc(5);
 * @endcode
 *
 *
 * @section cla3p_tutorial_vectors_dense_create Creating vectors
 * In CLA3P, you can declare or create dense vectors using several methods
 * depending on whether you need a new allocation, a specific constant value,
 * a random set of entries, or a wrapper for existing data.
 *
 *   @subsection cla3p_tutorial_vectors_dense_create_default Default creation
 *   Creates an empty vector object with a size of zero. No memory is allocated.
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex01a_dense_vector_create.cpp </td>
 *       <td> @include i32/out/ex01a_dense_vector_create.out </td>
 *     </tr>
 *   </table>
 *
 *   @subsection cla3p_tutorial_vectors_dense_create_random Create random dense vector
 *   Allocates memory for a vector of a specific size. Elements are uninitialized and contain indeterminate values.
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex01d_dense_vector_create_random.cpp </td>
 *       <td> @include i32/out/ex01d_dense_vector_create_random.out </td>
 *     </tr>
 *   </table>
 *
 *   @subsection cla3p_tutorial_vectors_dense_create_aux Create dense vector from aux data
 *   Creates a vector that acts as a "view" or wrapper around an existing C-style array.
 *   This avoids a deep copy of the data.
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex01c_dense_vector_create_from_aux_data.cpp </td>
 *       <td> @include i32/out/ex01c_dense_vector_create_from_aux_data.out </td>
 *     </tr>
 *   </table>
 *
 *
 * @section cla3p_tutorial_vectors_dense_fill Accessing dense vector elements
 * In CLA3P, you can access or modify the elements of dense vectors using
 * standard indexing operators or specialized fill methods.
 * 1) **Element Access and Assignment**: Dense vectors in CLA3P use the operator() 
 *    for 0-indexed element access. This operator can be used for both retrieving 
 *    and assigning values.@n
 * 2) **Batch Filling**: You can fill the entire vector with a single scalar value using the
 *    class member function or assignment logic.
 * <table>
 *   <tr><th>Code</th><th>Output</th></tr>
 *   <tr>
 *     <td> @include     src/ex01b_dense_vector_fill.cpp </td>
 *     <td> @include i32/out/ex01b_dense_vector_fill.out </td>
 *   </tr>
 * </table>
 *
 *
 * @section cla3p_tutorial_vectors_dense_algebra Algebra
 * CLA3P provides an intuitive interface for performing common algebraic operations
 * on dense vectors, including scaling, addition, and dot products.
 *
 *   @subsection cla3p_tutorial_vectors_dense_algebra_scale Scale
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex01i_dense_vector_algebra_scale.cpp </td>
 *       <td> @include i32/out/ex01i_dense_vector_algebra_scale.out </td>
 *     </tr>
 *   </table>
 *
 *   @subsection cla3p_tutorial_vectors_dense_algebra_add Add
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex01j_dense_vector_algebra_add.cpp </td>
 *       <td> @include i32/out/ex01j_dense_vector_algebra_add.out </td>
 *     </tr>
 *   </table>
 *
 *   @subsection cla3p_tutorial_vectors_dense_algebra_dot Dot Product
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex01k_dense_vector_algebra_dot.cpp </td>
 *       <td> @include i32/out/ex01k_dense_vector_algebra_dot.out </td>
 *     </tr>
 *   </table>
 *
 *
 *
 *
 *
 *
 * @page cla3p_tutorial_property Property
 *
 * The @ref cla3p::Property class provides a mechanism to define structural characteristics of matrices, 
 * such as symmetry or Hermitian properties. These properties are essential for optimizing 
 * storage and selecting high-performance computational kernels.
 *
 * ### Structure
 *
 * A @ref cla3p::Property consists of two primary attributes:
 *
 * - **@ref cla3p::prop_t prop:** Defines the matrix type (e.g., General, Symmetric, Hermitian).
 * - **@ref cla3p::uplo_t uplo:** Specifies which part of the matrix (Upper or Lower) contains the relevant data 
 *   for structured types.
 *
 * ### Property Definition
 *
 * Properties can be defined manually via the class constructor or through static factory methods 
 * provided by the @ref cla3p::Property class for convenience.
 *
 * | Property Method | Type | Data Part |
 * | :--- | :--- | :--- |
 * | `cla3p::Property::General()` | General | Full |
 * | `cla3p::Property::SymmetricLower()` | Symmetric | Lower Triangular |
 * | `cla3p::Property::SymmetricUpper()` | Symmetric | Upper Triangular |
 * | `cla3p::Property::HermitianLower()` | Hermitian | Lower Triangular |
 * | `cla3p::Property::HermitianUpper()` | Hermitian | Upper Triangular |
 *
 * ### Usage Example
 *
 * The following example demonstrates how to create and inspect various matrix properties:
 *
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex00_property_create.cpp </td>
 *     <td> @include i32/out/ex00_property_create.out </td>
 *   </tr>
 * </table>
 *
 *
 *
 *
 *
 *
 * @page cla3p_tutorial_matrices Matrices
 *  - @subpage cla3p_tutorial_matrices_dense
 *  - @subpage cla3p_tutorial_matrices_sparse
 *  - @subpage cla3p_tutorial_matrices_lowrank
 *
 * @page cla3p_tutorial_matrices_dense Dense Matrices
 *
 * CLA3P provides specialized classes for dense matrix operations, supporting both real and complex 
 * numerical types with single and double precision. These classes are optimized for 
 * high-performance linear algebra tasks.
 *
 * ### Available Dense Matrix Types
 *
 * The following classes are defined within the `cla3p::dns` namespace:
 *
 * | CLA3P Class | Numeric Type | Precision |
 * | :--- | :--- | :--- |
 * | @ref cla3p::dns::RdMatrix | `double` | Double precision real |
 * | @ref cla3p::dns::RfMatrix | `float` | Single precision real |
 * | @ref cla3p::dns::CdMatrix | `std::complex<double>` | Double precision complex |
 * | @ref cla3p::dns::CfMatrix | `std::complex<float>` | Single precision complex |
 *
 * Example:
 * @code{.cpp}
 * // Instantiate a double precision real matrix (e.g., 3x3)
 * cla3p::dns::RdMatrix Ad(3, 3);
 * 
 * // Instantiate a single precision complex matrix (e.g., 5x2)
 * cla3p::dns::CfMatrix Ac(5, 2);
 * @endcode
 *
 *
 * @section cla3p_tutorial_matrices_dense_create Creating matrices
 * In CLA3P, dense matrices can be instantiated through various methods, 
 * depending on whether you require a fresh allocation, a specific mathematical structure, 
 * or a wrapper for existing memory.
 *
 *   @subsection cla3p_tutorial_matrices_dense_create_default Default creation
 *   1) **Default Declaration**: Creates an empty matrix object with zero rows and columns. 
 *      No memory is allocated.@n
 *   2) **Sized Declaration**: Allocates memory for a matrix of size (m x n). 
 *      Elements are uninitialized and contain indeterminate values.
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex02a_dense_matrix_create.cpp </td>
 *       <td> @include i32/out/ex02a_dense_matrix_create.out </td>
 *     </tr>
 *   </table>
 *
 *   @subsection cla3p_tutorial_matrices_dense_create_property Default creation with property
 *   Allocates memory for a matrix of size (m x n) with a specified structural property.
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex02c_dense_matrix_create_with_property.cpp </td>
 *       <td> @include i32/out/ex02c_dense_matrix_create_with_property.out </td>
 *     </tr>
 *   </table>
 *
 *   @subsection cla3p_tutorial_matrices_dense_create_random Create random dense matrix
 *   Allocates memory for a matrix of size (m x n). Elements are initialized with random values.
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex02e_dense_matrix_create_random.cpp </td>
 *       <td> @include i32/out/ex02e_dense_matrix_create_random.out </td>
 *     </tr>
 *   </table>
 *
 *   @subsection cla3p_tutorial_matrices_dense_create_aux Create dense matrix from aux data
 *   Creates a matrix that "views" an existing C-style array (column-major order). This avoids copying large datasets.
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex02d_dense_matrix_create_from_aux_data.cpp </td>
 *       <td> @include i32/out/ex02d_dense_matrix_create_from_aux_data.out </td>
 *     </tr>
 *   </table>
 *
 *
 * @section cla3p_tutorial_matrices_dense_fill Accessing matrix elements
 * In CLA3P, dense matrices are stored in column-major order. 
 * You can access or modify elements using the 0-indexed operator 
 * or perform bulk fills.
 * <table>
 *   <tr><th>Code</th><th>Output</th></tr>
 *   <tr>
 *     <td> @include     src/ex02b_dense_matrix_fill.cpp </td>
 *     <td> @include i32/out/ex02b_dense_matrix_fill.out </td>
 *   </tr>
 * </table>
 *
 *
 * @section cla3p_tutorial_matrices_dense_algebra Algebra
 * CLA3P provides a high-performance interface for dense matrix algebra, 
 * leveraging optimized BLAS and LAPACK backends. Operations include standard arithmetic, 
 * linear combinations, and matrix-vector multiplications.
 *
 *   @subsection cla3p_tutorial_matrices_dense_algebra_scale Scale
 *   Matrices support in-place scaling and linear combinations using standard operators.
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex02k_dense_matrix_algebra_scale.cpp </td>
 *       <td> @include i32/out/ex02k_dense_matrix_algebra_scale.out </td>
 *     </tr>
 *   </table>
 *
 *   @subsection cla3p_tutorial_matrices_dense_algebra_add Add
 *   Matrices can be added together using overloaded operators or member functions.
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex02l_dense_matrix_algebra_add.cpp </td>
 *       <td> @include i32/out/ex02l_dense_matrix_algebra_add.out </td>
 *     </tr>
 *   </table>
 *
 *   @subsection cla3p_tutorial_matrices_dense_algebra_mvmult Matrix-Vector Product
 *   You can perform matrix-vector products using the `*` operator. 
 *   The resulting object is a dense vector of the appropriate precision.
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex02m_dense_matrix_algebra_vmult.cpp </td>
 *       <td> @include i32/out/ex02m_dense_matrix_algebra_vmult.out </td>
 *     </tr>
 *   </table>
 *
 *   @subsection cla3p_tutorial_matrices_dense_algebra_mmmult Matrix-Matrix Product
 *   Dense matrices can be multiplied together, provided their dimensions are compatible.
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex02n_dense_matrix_algebra_mmult.cpp </td>
 *       <td> @include i32/out/ex02n_dense_matrix_algebra_mmult.out </td>
 *     </tr>
 *   </table>
 *
 *   @subsection cla3p_tutorial_matrices_dense_algebra_mtmmult Transposed Matrix-Matrix Product
 *   You can perform matrix-matrix products involving the transpose of a matrix.
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex02o_dense_matrix_algebra_mtmult.cpp </td>
 *       <td> @include i32/out/ex02o_dense_matrix_algebra_mtmult.out </td>
 *     </tr>
 *   </table>
 *
 *
 *
 *
 *
 *
 * @page cla3p_tutorial_matrices_sparse Sparse Matrices
 *
 * CLA3P supports specialized storage formats for sparse matrices, each optimized for different 
 * stages of the numerical pipeline:
 *
 * - **Coordinate Format (COO):** A triplet-based storage (`row`, `col`, `value`) designed for 
 *   flexible ad-hoc construction and efficient element insertion.
 * - **Compressed Sparse Column (CSC):** A column-oriented format optimized for high-performance 
 *   arithmetic operations and linear solvers.
 *
 * @note **Future Support:** While CSC is currently the primary format for algebraic operations, 
 * support for the **Compressed Sparse Row (CSR)** format is currently under development for 2026 
 * and will be available in a future release.
 *
 * ### Available Sparse Matrix Types
 *
 * The following classes are available for real and complex data across both formats:
 *
 * @code{.cpp}
 * // Coordinate Format (Utility classes for construction)
 * cla3p::coo::RdMatrix Ad_coo; // Double precision real
 * cla3p::coo::RfMatrix As_coo; // Single precision real
 * cla3p::coo::CdMatrix Az_coo; // Double precision complex
 * cla3p::coo::CfMatrix Ac_coo; // Single precision complex
 *
 * // Compressed Sparse Column Format (Main classes for algebra)
 * cla3p::csc::RdMatrix Ad_csc; // Double precision real
 * cla3p::csc::RfMatrix As_csc; // Single precision real
 * cla3p::csc::CdMatrix Az_csc; // Double precision complex
 * cla3p::csc::CfMatrix Ac_csc; // Single precision complex
 * @endcode
 *
 * ### Workflow Recommendation
 *
 * For optimal performance, it is recommended to:
 * 1. **Build** the sparse structure using the **COO** format to facilitate easy data ingestion.
 * 2. **Convert** the COO matrix to **CSC** format to perform fast matrix-vector products and 
 *    arithmetic operations.
 *
 *
 * @section cla3p_tutorial_matrices_sparse_create Creating matrices
 * In CLA3P, sparse matrices are typically constructed using the COO format for data ingestion 
 * and then converted to CSC for computational tasks. The following methods describe how to 
 * instantiate these structures:
 *
 *   @subsection cla3p_tutorial_matrices_sparse_create_default Default creation
 *   1) Creates an empty sparse matrix object with zero dimensions and no allocated entries.@n
 *   2) Allocates a Coordinate matrix with specific dimensions and a reserve capacity for non-zero 
 *      elements ('nnz'). This is the standard way to begin building a sparse matrix.
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex06a_sparse_matrix_create.cpp </td>
 *       <td> @include i32/out/ex06a_sparse_matrix_create.out </td>
 *     </tr>
 *   </table>
 *
 *   @subsection cla3p_tutorial_matrices_sparse_create_property Default creation with property
 *   Similar to dense matrices, you can specify structural properties (e.g., symmetry) during construction.
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex06c_sparse_matrix_create_with_property.cpp </td>
 *       <td> @include i32/out/ex06c_sparse_matrix_create_with_property.out </td>
 *     </tr>
 *   </table>
 *
 *   @subsection cla3p_tutorial_matrices_sparse_create_aux Create sparse matrix from aux data
 *   You can wrap existing CSC data (column pointers, row indices, and values) into a CLA3P object 
 *   without copying the underlying memory.
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex06d_sparse_matrix_create_from_aux_data.cpp </td>
 *       <td> @include i32/out/ex06d_sparse_matrix_create_from_aux_data.out </td>
 *     </tr>
 *   </table>
 *
 *
 * @section cla3p_tutorial_matrices_sparse_fill Inserting matrix elements
 * Since the CSC format is rigid and difficult to fill directly, it is typically created 
 * by converting a populated COO matrix.
 * <table>
 *   <tr><th>Code</th><th>Output</th></tr>
 *   <tr>
 *     <td> @include     src/ex06b_sparse_matrix_fill.cpp </td>
 *     <td> @include i32/out/ex06b_sparse_matrix_fill.out </td>
 *   </tr>
 * </table>
 *
 *
 * @section cla3p_tutorial_matrices_sparse_algebra Algebra
 * In CLA3P, sparse algebraic operations are primarily performed using matrices in CSC format. 
 * These operations are highly optimized for matrices with a large percentage of zero entries.
 *
 *   @subsection cla3p_tutorial_matrices_sparse_algebra_scale Scale
 *   Matrices support in-place scaling using standard operators.
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex06k_sparse_matrix_algebra_scale.cpp </td>
 *       <td> @include i32/out/ex06k_sparse_matrix_algebra_scale.out </td>
 *     </tr>
 *   </table>
 *
 *   @subsection cla3p_tutorial_matrices_sparse_algebra_add Add
 *   Matrices can be added together using overloaded operators or member functions.
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex06l_sparse_matrix_algebra_add.cpp </td>
 *       <td> @include i32/out/ex06l_sparse_matrix_algebra_add.out </td>
 *     </tr>
 *   </table>
 *
 *   @subsection cla3p_tutorial_matrices_sparse_algebra_mvmult Matrix-Vector Product
 *   You can perform multiplication between a sparse matrix and a dense vector using the * operator. 
 *   The result is always a dense vector.
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex06m_sparse_matrix_algebra_vmult.cpp </td>
 *       <td> @include i32/out/ex06m_sparse_matrix_algebra_vmult.out </td>
 *     </tr>
 *   </table>
 *
 *   @subsection cla3p_tutorial_matrices_sparse_algebra_mmmult Matrix-Matrix Product
 *   Sparse matrices can be multiplied together, provided their dimensions are compatible.@n
 *   1) Multiplication between a sparse matrix and a dense matrix is supported, resulting in a dense matrix.@n
 *   2) Multiplication between two sparse matrices is supported, resulting in a sparse matrix.@n
 *   3) Multiplication involving the transpose of a sparse matrix is also supported.
 *   
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex06n_sparse_matrix_algebra_mmult.cpp </td>
 *       <td> @include i32/out/ex06n_sparse_matrix_algebra_mmult.out </td>
 *     </tr>
 *   </table>
 *
 *
 *
 *
 *
 *
 * @page cla3p_tutorial_matrices_lowrank Low-rank Matrices
 *
 * CLA3P provides specialized support for low-rank matrices, which are represented 
 * as the product of two smaller dense matrices (e.g., \f$ L_{m \times n} = A_{m \times k} \cdot B^*_{n \times k} \f$). 
 * This format significantly reduces memory overhead and computational cost for high-dimensional 
 * data with low intrinsic rank.
 *
 * ### Available Low-rank Matrix Types
 *
 * You can instantiate low-rank matrices using either the generic template class 
 * or the simplified standard aliases within the `cla3p::lra` namespace.
 *
 * #### Using Template Classes
 * The @ref cla3p::lra::XxMatrix template allows for explicit precision control:
 *
 * @code{.cpp}
 * cla3p::lra::RdMatrix Ld; // Double precision real
 * cla3p::lra::RfMatrix Ls; // Single precision real
 * cla3p::lra::CdMatrix Lz; // Double precision complex
 * cla3p::lra::CfMatrix Lc; // Single precision complex
 * @endcode
 *
 * #### Using Standard Aliases
 * CLA3P provides the following predefined typedefs:
 *
 * | CLA3P Alias | Numeric Type | Underlying Template |
 * | :--- | :--- | :--- |
 * | @ref cla3p::lra::RdMatrix | `double` | @ref cla3p::lra::XxMatrix<@ref cla3p::dns::RdMatrix> |
 * | @ref cla3p::lra::RfMatrix | `float` | @ref cla3p::lra::XxMatrix<@ref cla3p::dns::RfMatrix> |
 * | @ref cla3p::lra::CdMatrix | `std::complex<double>` | @ref cla3p::lra::XxMatrix<@ref cla3p::dns::CdMatrix> |
 * | @ref cla3p::lra::CfMatrix | `std::complex<float>` | @ref cla3p::lra::XxMatrix<@ref cla3p::dns::CfMatrix> |
 *
 * Example:
 * @code{.cpp}
 * // Create a double precision low-rank matrix
 * cla3p::lra::RdMatrix L; 
 * @endcode
 *
 *
 * @section cla3p_tutorial_matrices_lowrank_create Creating matrices
 * In CLA3P, low-rank matrices are managed via the XxMatrix class, which stores the factorized 
 * components `A` and `B`. You can create these matrices through direct instantiation or by 
 * approximating existing dense and sparse data.
 *
 *   @subsection tutorial_matrices_lowrank_create_default Default creation
 *   Creates an empty low-rank matrix object with zero dimensions and rank. No memory is allocated.
 *   <table>
 *     <tr><th>Code</th><th>Output</th></tr>
 *     <tr>
 *       <td> @include     src/ex09a_lowrank_matrix_create.cpp </td>
 *       <td> @include i32/out/ex09a_lowrank_matrix_create.out </td>
 *     </tr>
 *   </table>
 *
 *
 *
 *
 *
 *
 * @page cla3p_tutorial_guard Guards
 *
 * The @ref cla3p::Guard class is a utility wrapper designed for memory safety and data integrity. 
 * Certain CLA3P functions return objects containing data that must not be modified or reallocated 
 * by the user (e.g., internal library states or shared buffers). 
 *
 * Instead of returning the raw vector or matrix, these functions return a @ref cla3p::Guard, 
 * ensuring that the underlying data remains immutable.
 *
 * ### Key Features
 * - **Immutability:** Provides read-only access to the guarded object.
 * - **Safe Retrieval:** Use the @ref cla3p::Guard::get() member function to obtain a `const` 
 *   reference to the internal object.
 * - **Custom Guards:** Users can wrap their own objects to prevent accidental modification in 
 *   subsequent code blocks.
 *
 * ### Usage Example
 *
 * The following example demonstrates how to create a guard for dense objects and retrieve 
 * references for inspection:
 *
 * @code{.cpp}
 * // Create standard objects
 * const cla3p::dns::RdVector X = cla3p::dns::RdVector::random(3);
 * const cla3p::dns::RdMatrix A = cla3p::dns::RdMatrix::random(3,3);
 *
 * // Wrap objects in guards
 * cla3p::Guard<cla3p::dns::RdVector> Xgrd(X);
 * cla3p::Guard<cla3p::dns::RdMatrix> Agrd(A);
 *
 * // Access the guarded data via const reference
 * const cla3p::dns::RdVector& Xref = Xgrd.get();
 * const cla3p::dns::RdMatrix& Aref = Agrd.get();
 *
 * // Inspect the objects
 * std::cout << Xref.info() << Xref << std::endl;
 * std::cout << Aref.info() << Aref << std::endl;
 * @endcode
 *
 *
 *
 *
 *
 *
 * @page cla3p_tutorial_assign Assignments & Data Transfer
 *
 * CLA3P provides flexible mechanisms for duplicating, moving, and referencing data within vectors and matrices. 
 * Standard C++ copy/move constructors and assignment operators are fully supported across all object types.
 *
 * @section cla3p_tutorial_assign_copy Deep Copying
 * A deep copy creates an independent duplicate of the source object. Modifications made to the new object 
 * do not affect the original.
 * 
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex01e_dense_vector_copy.cpp </td>
 *     <td> @include i32/out/ex01e_dense_vector_copy.out </td>
 *   </tr>
 *   <tr>
 *     <td> @include src/ex02f_dense_matrix_copy.cpp </td>
 *     <td> @include i32/out/ex02f_dense_matrix_copy.out </td>
 *   </tr>
 * </table>
 *
 * @section cla3p_tutorial_assign_move Moving
 * Moving transfers ownership of the underlying data from the source to the target. This is a high-performance 
 * operation as it avoids memory reallocation. The original (source) object is left in an empty/null state.
 * 
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex01f_dense_vector_move.cpp </td>
 *     <td> @include i32/out/ex01f_dense_vector_move.out </td>
 *   </tr>
 *   <tr>
 *     <td> @include src/ex02g_dense_matrix_move.cpp </td>
 *     <td> @include i32/out/ex02g_dense_matrix_move.out </td>
 *   </tr>
 * </table>
 *
 * @section cla3p_tutorial_assign_rcopy Shallow Copying (Referencing)
 * A shallow copy creates a new object that points to the same memory address as the original. 
 * @warning **Caution:** Since both objects share the same data buffer, modifying one will immediately affect 
 * the other. Ensure the original object remains in scope as long as the shallow copy is in use.
 * 
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex01h_dense_vector_shallow_copy.cpp </td>
 *     <td> @include i32/out/ex01h_dense_vector_shallow_copy.out </td>
 *   </tr>
 *   <tr>
 *     <td> @include src/ex02h_dense_matrix_shallow_copy.cpp </td>
 *     <td> @include i32/out/ex02h_dense_matrix_shallow_copy.out </td>
 *   </tr>
 * </table>
 *
 *
 *
 *
 *
 *
 *
 * @page cla3p_tutorial_block_ops Block Operations
 *
 * CLA3P provides efficient methods to extract or modify specific segments of dense vectors and matrices. 
 * These operations are categorized into **Data Referencing** (shallow copy) and **Data Copying** (deep copy).
 *
 * ### Data Referencing (Shallow Copy)
 * Referencing functions return a new object that points to the memory of the original object. 
 * No data is duplicated, making these operations extremely fast.
 * @warning Modifications to a reference will directly affect the original data.
 * 
 * - `rblock()`: Returns a reference to a contiguous segment or sub-matrix.
 * - `rcolumn()`: Returns a reference to a specific matrix column as a vector.
 *
 * ### Data Copying (Deep Copy)
 * Copying functions allocate new memory and duplicate the specified segment. The new object 
 * is entirely independent of the original.
 * 
 * - `block()`: Returns a deep copy of a sub-segment or sub-matrix.
 * - `column()`: Returns a deep copy of a matrix column as a vector.
 *
 * ### Examples
 *
 * #### Dense Vector Blocks
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex01g_dense_vector_block_operations.cpp </td>
 *     <td> @include i32/out/ex01g_dense_vector_block_operations.out </td>
 *   </tr>
 * </table>
 *
 * #### Dense Matrix Blocks
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex02i_dense_matrix_block_operations.cpp </td>
 *     <td> @include i32/out/ex02i_dense_matrix_block_operations.out </td>
 *   </tr>
 * </table>
 *
 * #### Matrix Column Operations
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex02j_dense_matrix_column_operations.cpp </td>
 *     <td> @include i32/out/ex02j_dense_matrix_column_operations.out </td>
 *   </tr>
 * </table>
 *
 *
 *
 *
 *
 *
 * @page cla3p_tutorial_perm Permutations
 * 
 * This section covers the creation and application of permutation matrices in CLA3P.
 * 
 * - @subpage cla3p_tutorial_perm_matrix
 * - @subpage cla3p_tutorial_perm_ops
 *
 * @page cla3p_tutorial_perm_matrix Permutation Matrix
 *
 * <a href="https://en.wikipedia.org/wiki/Permutation_matrix">Permutation matrices</a> are used to rearrange the entries of vectors or matrices. 
 * In CLA3P, a permutation matrix is represented as a 1D entity containing an array of integers, where each value at index `i` represents the new position of the element.
 * 
 * CLA3P utilizes 0-based indexing, meaning an n-sized matrix contains values in the range [0, n-1]. 
 * The primary class for these operations is @ref cla3p::prm::PxMatrix<cla3p::int_t>.
 *
 * @section cla3p_tutorial_perm_matrix_create Creating permutation matrices
 *
 * You can instantiate permutation matrices using default constructors, identity factory methods, or random generation.
 *
 * @subsection cla3p_tutorial_perm_matrix_create_default Default creation
 * <table>
 *   <tr><th>Source Code</th><th>Output (i32)</th><th>Output (i64)</th></tr>
 *   <tr>
 *     <td> @include src/ex03a_permutation_matrix_create.cpp </td>
 *     <td> @include i32/out/ex03a_permutation_matrix_create.out </td>
 *     <td> @include i64/out/ex03a_permutation_matrix_create.out </td>
 *   </tr>
 * </table>
 *
 * @subsection cla3p_tutorial_perm_matrix_create_identity Create Identity
 * <table>
 *   <tr><th>Source Code</th><th>Output (i32)</th><th>Output (i64)</th></tr>
 *   <tr>
 *     <td> @include src/ex03c_permutation_matrix_create_identity.cpp </td>
 *     <td> @include i32/out/ex03c_permutation_matrix_create_identity.out </td>
 *     <td> @include i64/out/ex03c_permutation_matrix_create_identity.out </td>
 *   </tr>
 * </table>
 *
 * @subsection cla3p_tutorial_perm_matrix_create_random Create Random
 * <table>
 *   <tr><th>Source Code</th><th>Output (i32)</th><th>Output (i64)</th></tr>
 *   <tr>
 *     <td> @include src/ex03d_permutation_matrix_create_random.cpp </td>
 *     <td> @include i32/out/ex03d_permutation_matrix_create_random.out </td>
 *     <td> @include i64/out/ex03d_permutation_matrix_create_random.out </td>
 *   </tr>
 * </table>
 *
 * @section cla3p_tutorial_perm_matrix_fill Accessing permutation matrix elements
 * Elements of a permutation matrix can be accessed and modified using standard indexing.
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex03b_permutation_matrix_fill.cpp </td>
 *     <td> @include i32/out/ex03b_permutation_matrix_fill.out </td>
 *   </tr>
 * </table>
 *
 * @page cla3p_tutorial_perm_ops Permutation Operations
 *
 * CLA3P supports applying permutations to various objects using both operator overloading and member functions.
 *
 * @section cla3p_tutorial_perm_ops_vector Permuting vectors
 * Rearrange elements of a dense vector.
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex03e_permutation_matrix_permute_vector.cpp </td>
 *     <td> @include i32/out/ex03e_permutation_matrix_permute_vector.out </td>
 *   </tr>
 * </table>
 *
 * @section cla3p_tutorial_perm_ops_matrix Permuting matrices
 * Permute rows or columns of a dense matrix.
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex03f_permutation_matrix_permute_matrix.cpp </td>
 *     <td> @include i32/out/ex03f_permutation_matrix_permute_matrix.out </td>
 *   </tr>
 * </table>
 *
 * @section cla3p_tutorial_perm_ops_matrix_sym Permuting symmetric/hermitian matrices
 * Specialized permutation for matrices with structural properties, ensuring the resulting matrix maintains its property.
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex03g_permutation_matrix_permute_matrix_symmetric.cpp </td>
 *     <td> @include i32/out/ex03g_permutation_matrix_permute_matrix_symmetric.out </td>
 *   </tr>
 * </table>
 *
 * @section cla3p_tutorial_perm_ops_perm Permuting permutation matrices
 * Combine or rearrange permutation matrices themselves.
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex03h_permutation_matrix_permute_permutation_matrix.cpp </td>
 *     <td> @include i32/out/ex03h_permutation_matrix_permute_permutation_matrix.out </td>
 *   </tr>
 * </table>
 *
 *
 *
 *
 *
 *
 * @page cla3p_tutorial_linsol Linear System Solvers
 * 
 * CLA3P provides high-performance linear system solvers for both dense and sparse matrices, utilizing optimized backends such as LAPACK and Intel® MKL Pardiso.
 * 
 * - @subpage cla3p_tutorial_linsol_lapack
 * - @subpage cla3p_tutorial_linsol_pardiso
 *
 * @page cla3p_tutorial_linsol_lapack Dense (Lapack Based)
 *
 * This section demonstrates how to solve dense systems of linear equations using standard factorization methods.
 *
 * @section cla3p_tutorial_linsol_lapack_lu LU Decomposition (General/Symmetric/Hermitian Matrices)
 * Performs LU factorization with partial pivoting for general matrices.
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex05a_solving_linear_systems_lu.cpp </td>
 *     <td> @include i32/out/ex05a_solving_linear_systems_lu.out </td>
 *   </tr>
 * </table>
 *
 * @section cla3p_tutorial_linsol_lapack_ldlt LDL' Decomposition (Symmetric/Hermitian Matrices)
 * Performs Bunch-Kaufman diagonal pivoting factorization for symmetric or Hermitian matrices.
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex05b_solving_linear_systems_ldlt.cpp </td>
 *     <td> @include i32/out/ex05b_solving_linear_systems_ldlt.out </td>
 *   </tr>
 * </table>
 *
 * @section cla3p_tutorial_linsol_lapack_auto Auto Detect Decomposition Method
 * CLA3P can automatically select the most efficient solver based on the matrix @ref cla3p::Property.
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex05c_solving_linear_systems_auto.cpp </td>
 *     <td> @include i32/out/ex05c_solving_linear_systems_auto.out </td>
 *   </tr>
 * </table>
 *
 * @page cla3p_tutorial_linsol_pardiso Pardiso (Intel® MKL)
 *
 * This section covers the solution of large-scale sparse linear systems using the Intel® MKL Pardiso solver integration.
 *
 * @section cla3p_tutorial_linsol_pardiso_lu LU Decomposition (General Matrices)
 * Sparse LU factorization for non-symmetric systems.
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex07a_solving_sparse_linear_systems_lu.cpp </td>
 *     <td> @include i32/out/ex07a_solving_sparse_linear_systems_lu.out </td>
 *   </tr>
 * </table>
 *
 * @section cla3p_tutorial_linsol_pardiso_ldlt LDL' Decomposition (Symmetric/Hermitian Indefinite Matrices)
 * Factorization for sparse symmetric indefinite or Hermitian matrices.
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex07c_solving_sparse_linear_systems_ldlt.cpp </td>
 *     <td> @include i32/out/ex07c_solving_sparse_linear_systems_ldlt.out </td>
 *   </tr>
 * </table>
 *
 * @section cla3p_tutorial_linsol_pardiso_auto Auto Detect Decomposition Method
 * Automatic solver selection for sparse systems based on the input matrix characteristics.
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex07e_solving_sparse_linear_systems_auto.cpp </td>
 *     <td> @include i32/out/ex07e_solving_sparse_linear_systems_auto.out </td>
 *   </tr>
 * </table>
 *
 *
 *
 *
 *
 *
 *
 * @page cla3p_tutorial_qr QR Decomposition
 *
 * CLA3P provides specialized routines to perform QR decomposition on dense matrices. 
 * This factorization decomposes a matrix into an orthogonal matrix \f$ Q \f$ and an 
 * upper triangular matrix \f$ R \f$, such that \f$ A = QR \f$.
 *
 * ### Example
 *
 * The following example demonstrates how to compute the QR decomposition of a dense matrix:
 *
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex08a_qr_decomposition.cpp </td>
 *     <td> @include i32/out/ex08a_qr_decomposition.out </td>
 *   </tr>
 * </table>
 *
 *
 *
 *
 *
 *
 * @page cla3p_tutorial_svd Singular Value Decomposition
 *
 * CLA3P provides high-performance routines to compute the Singular Value Decomposition (SVD) 
 * of a dense matrix. This factorization decomposes a matrix into two unitary matrices 
 * \f$ U \f$ and \f$ V \f$, and a diagonal matrix \f$ \Sigma \f$ containing the singular 
 * values, such that \f$ A = U \Sigma V^* \f$.
 *
 * ### Example
 *
 * The following example demonstrates how to perform a singular value decomposition 
 * on a dense matrix and retrieve the components:
 *
 * <table>
 *   <tr><th>Source Code</th><th>Console Output</th></tr>
 *   <tr>
 *     <td> @include src/ex08b_sv_decomposition.cpp </td>
 *     <td> @include i32/out/ex08b_sv_decomposition.out </td>
 *   </tr>
 * </table>
 */
